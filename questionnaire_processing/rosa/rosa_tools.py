"""
Functions to calculate the ROSA score
Each score card has its own function. Additionally, there is a function that does the entire calculation
of the ROSA score based on a pandas dataframe / array extracted from a pandas dataframe
The calculations of the scores are based on:
https://www.sciencedirect.com/science/article/abs/pii/S0003687011000433
The functions found here do have some minor deviations because for PrevOccupAI some additional questions were created.
However, the ROSA scales are kept the same. The points from the new questions are inserted into the rosa scale and then
the scale is re-scaled to its original range.
"""
import questionnaire_processing.rosa.rosa_question_mappings as rosa_qm
import questionnaire_processing.rosa.rosa_score_cards as rosa_sc
import numpy as np
import pandas as pd


def replace_values_by_mapping(df, mappings_list):
    """
    Function for replacing the limesurvey generated values with the ones defined in a nested mapping dictionary.
    The function should be called like the following:
     - if one nested dictionary is used:
     replace_values_by_mapping(df, [rosa_mappings_section_a])
     - if multiple nested dictionaries are used:
     replace_values_by_mapping(df, [rosa_mappings_section_a, rosa_mappings_section_b, ...])
    :param mappings_list: a list containing nested dictionaries that have the mappings for each multiple choice question.
    The key (i.e. the names of the sub-dictionaries should be equal to the column names of the csv files generated by limesurvey.
    :param df: dataframe containing the csv file data generated by limesurvey
    :return: no return type; the dataframe is overwritten by this function
    """
    # cycle over the mappings contained in the mappings list
    for mappings in mappings_list:

        # cycle over the mappings
        for mapping in mappings:

            # replace the limesurvey values according to the mapping
            df[mapping].replace(mappings[mapping], inplace=True)


def replace_yes_no(df):
    """
    function to replace all yes/no question with their respective numeric value according to the sn dictonary
    defined above
    :param df: dataframe containing the csv file data generated by limesurvey
    :return:  no return type; the dataframe is overwritten by this function
    """

    # replace Y with 0 and N with 1
    df.replace(rosa_qm.sn, inplace=True)


def replace_nan(df):
    """
    function to replace NaN values within the dataframe with zeros. This function is applied to the answers that the
    user has give. In some instances the when the user chooses a certain option some questions are not shown because
    they are not relevant. In this instance limesurvey will keep the question empty and when loading the dataframe
    with pandas the value will be NaN. These values are replaced with zeroes.
    :param df: dataframe containing the csv file data generated by limesurvey
    :return: no return type; the dataframe is overwritten by this function
    """

    df_sub = df.loc[:, 'id.1':]
    df_sub = df_sub.fillna(0)
    df.loc[:, 'id.1':] = df_sub


def normalise_to_range(series, score_card_dict, score_type='vertical', answer='monitor'):
    """
    function to normalise a series to a range defined in the score_card_dict
    :param series: a pandas series with values that need to be normalised
    :param score_card_dict: score card dictionary with the min and max scores of the range to which the values should be
    normalised. The dictionaries can be found in rosa_score_cards.py
    :param score_type: if it is either a vertical or  horizontal score (according to the score card)
    :param answer: used to distinguish between chair scores and non-chair scores, to return properly
    :return: returns a normalised series
    """
    # check if it is a horizontal or vertical score

    if score_type == 'vertical':
        # normalise between 0-1 using the new maximums that result from adding the new questions
        normalised = (series - score_card_dict['min']) / (score_card_dict['max_vertical_new'] - score_card_dict['min'])

        # scale to the ROSA range
        scaled = (normalised * (score_card_dict['max_vertical'] - score_card_dict['min'])) + score_card_dict['min']

    elif score_type == 'horizontal':

        # normalise between 0-1 using the new maximums that result from adding the new questions
        normalised = (series - score_card_dict['min']) / (score_card_dict['max_horizontal_new'] - score_card_dict['min'])

        # scale to the ROSA range
        scaled = (normalised * (score_card_dict['max_horizontal'] - score_card_dict['min'])) + score_card_dict['min']

    else:

        IOError('score_type must be either \'horizontal\' or \'vertical\'')
        normalised = 0
        scaled = 0

    if answer == 'cadeira':
        return scaled
    else:
        return normalised


def get_score_from_card(vertical_score, horizontal_score, score_card_dict):
    """
    Function to get the rosa score from the score card. For details check the ROSA paper
    :param vertical_score: the vertical score along the score card (e.g. for card_b, the phone score is the vertical score)
    :param horizontal_score: the horizontal score along the score card (e.g. for card_b, the monitor is the horizontal score)
    :param score_card_dict: the corresponding score card dictionary. The dictionaries can be found in 'rosa_score_cards.py'
    :return: the score from the score card
    """
    return score_card_dict['matrix'][int(vertical_score)][int(horizontal_score)]


def pre_process_rosa(df, rosa_mappings_list):
    """
    Function to preprocess the ROSA data generated by limesurvey.
    :param rosa_mappings_list: a list of mappings
    :param df: dataframe containing the csv file data generated by limesurvey
    :return: returns the dataframe
    """

    # remove columns that do not have a submission date
    df = df[df['submitdate'].notna()]

    # drop older answer instances in case a user has answered a questionnaire multiple times
    # in this case only the newest answer instance is regarded
    idx = df.groupby(['id.1'])['submitdate'].transform(max) == df['submitdate']
    df = df[idx]

    # replace the limesurvey generated multiple choice answer with their real values according to the mappings defined
    # in rosa_question_mappings.py
    replace_values_by_mapping(df, rosa_mappings_list)

    # replace the limesurvey generated yes/no answers with numeric values according to the mapping defined in
    # rosa_question_mappings.py
    replace_yes_no(df)

    # replace NaN values for questions that have not been shown to user because they chose an option that made these
    # questions obsolete
    replace_nan(df)

    return df


def calc_a_score(df: pd.DataFrame, pure_rosa: bool) -> pd.DataFrame:
    """
    Function to calculate the score for score card A (arm rest / back support + seat pan height/depth)
    :param df: dataframe containing the answers to the questions.
    It is assumed that the dataframe  is in the following format:
    - the answers that have been chosen in the questionnaire have their respective values
    - the additional time factor is the first element in the array
    - column names are distinguishable by having the name of the assessed equipment
    (i.e. opDuracaoCadeira, snFormaAssento, opAnguloEncosto, etc.)
    :param pure_rosa: boolean indicating the type of score to be calculated. If True, calculate pure rosa score.
    If False, calculate the scores with the added questions
    :return: no return type; the dataframe is overwritten by this function
    """
    if pure_rosa:

        # drop all columns except the pure rosa ones
        df = df[rosa_qm.rosa_a_score_columns]

    # calculate the score for the chair (exclude the first value as this is the time factor)
    cadeira_score = df.filter(regex="Cadeira").iloc[:, 1:].sum(axis=1)

    # calculate the score for the seatpan
    seatpan_score = df.filter(regex="Assento").sum(axis=1)

    # sum the two scores
    cadeira_seatpan_score = cadeira_score + seatpan_score

    # calculate the score for the backrest
    backrest_score = df.filter(regex="Encosto").sum(axis=1)

    # calculate the score for the armrest
    armrest_score = df.filter(regex="Bra").sum(axis=1)

    # sum the two scores and the score for the desk
    arm_backrest_score = backrest_score + armrest_score + df.filter(regex="Mesa").squeeze()

    if not pure_rosa:

        # normalise the scores
        cadeira_seatpan_score = normalise_to_range(cadeira_seatpan_score, rosa_sc.card_a, score_type='vertical', answer='cadeira')
        arm_backrest_score = normalise_to_range(arm_backrest_score, rosa_sc.card_a, score_type='horizontal', answer='cadeira')

        # ceil the scores (always round up)
        cadeira_seatpan_score = cadeira_seatpan_score.apply(np.ceil)
        arm_backrest_score = arm_backrest_score.apply(np.ceil)

    # add the calculated scores as new columns
    df['seatpan_score'] = cadeira_seatpan_score
    df['arm_backrest_score'] = arm_backrest_score

    # get the rosa score according to the corresponding score card
    df['score_a_rosa'] = df.apply(lambda x: get_score_from_card(x['seatpan_score'], x['arm_backrest_score'], rosa_sc.card_a), axis=1)

    # get the time factor
    df['time_factor'] = df.filter(regex="Cadeira").iloc[:, 0]

    # add the time factor (for the score_a the time factor is added after getting the score from the card
    df['score_a_rosa'] = df['score_a_rosa'] + df['time_factor']

    # keep only the relevant columns
    df = df[['id.1', 'score_a_rosa']]

    # if it's not pure rosa, normalize the results
    if not pure_rosa:

        chair_score_min = rosa_sc.card_a['min']
        chair_score_max = rosa_sc.card_a['max_horizontal_new']
        df['score_a_normalized'] = ((df['score_a_rosa'] - chair_score_min)/(chair_score_max - chair_score_min)).round(2)

        # keep only the relevant columns
        df = df[['id.1', 'score_a_normalized']]

        # rename scores column name
        df.rename(columns={"score_a_normalized": "cadeira_adapted"})

    return df


def calc_b_c_scores(df: pd.DataFrame, pure_rosa: bool) -> pd.DataFrame:
    """
    Function to calculate the score for score card B (Phone + Monitor) and score card C (Mouse + Keyboard)
    :param df: dataframe containing the answers to the questions.
    It is assumed that the dataframe  is in the following format:
    - the answers that have been chosen in the questionnaire have their respective values
    - the additional time factor is the last element in the array telefone array and the one for the computer is called "opDuracaoComputador"
    - column names are distinguishable by having the name of the assessed equipment
    (i.e. opDuracaoCadeira, snFormaAssento, opAnguloEncosto, etc.)
    :param pure_rosa: boolean indicating the type of score to be calculated. If True, calculate pure rosa score.
    If False, calculate the scores with the added questions
    :return: no return type; the dataframe is overwritten by this function
    """
    if pure_rosa:

        # keep only the pure rosa columns
        df = df[rosa_qm.rosa_b_c_score_columns]

    # get the time factor for the monitor, keyboard & mouse (computer)
    tf_computer = df.filter(regex="Computador").replace({-3: -1, 0: 0, 3: 1}).squeeze()

    # calculate the monitor score
    monitor_score = df.filter(regex="Monitor").sum(axis=1)

    # calculate the phone score (exclude the last value as this is the time factor)
    telefone_score = df.filter(regex="Telefone").sum(axis=1)

    # calculate keyboard score (filter all column with the name Teclado, except snPosTecladoRato)
    keyboard_score = df.filter(regex=r"^(?!snPosTecladoRato$).*Teclado").sum(axis=1)

    # calculate mouse score
    mouse_score = df.filter(regex="Rato").sum(axis=1)

    # for section B and C the time is added before getting the score in the card
    # add the time factors for computer, mouse, keyboard
    monitor_score = monitor_score + tf_computer
    mouse_score = mouse_score + tf_computer
    keyboard_score = keyboard_score + tf_computer

    if pure_rosa:

        # add monitor, mouse, keyboard, and telephone scores to the df
        df['monitor_score'] = monitor_score
        df['mouse_score'] = mouse_score
        df['keyboard_score'] = keyboard_score
        df['phone_score'] = telefone_score

        # get the rosa score according to the corresponding score card
        df['score_b_rosa'] = df.apply(lambda x: get_score_from_card(x['phone_score'], x['monitor_score'], rosa_sc.card_b), axis=1)
        # get the rosa score according to the corresponding score card
        df['score_c_rosa'] = df.apply(lambda x: get_score_from_card(x['mouse_score'], x['keyboard_score'], rosa_sc.card_c), axis=1)

        # keep only the relevant columns
        df = df[['id.1', 'score_b_rosa', 'score_c_rosa']]

    else:

        # normalise the scores
        monitor_score = normalise_to_range(monitor_score, rosa_sc.card_b, score_type='vertical', answer='monitor').round(2)
        telefone_score = normalise_to_range(telefone_score, rosa_sc.card_b, score_type='horizontal', answer='telefone').round(2)
        mouse_score = normalise_to_range(mouse_score, rosa_sc.card_c, score_type='vertical', answer='mouse').round(2)
        keyboard_score = normalise_to_range(keyboard_score, rosa_sc.card_c, score_type='horizontal', answer='keyboard').round(2)

        # add the calculated scores as new columns
        df['monitor_score_adapted'] = monitor_score
        df['phone_score_adapted'] = telefone_score
        df['mouse_score_adapted'] = mouse_score
        df['keyboard_score_adapted'] = keyboard_score

        # keep only the relevant columns with the scores
        df = df[['id.1', 'monitor_score_adapted', 'phone_score_adapted', 'mouse_score_adapted', 'keyboard_score_adapted']]

    return df


def calc_final_rosa_score(df_a_scores: pd.DataFrame, df_b_c_scores: pd.DataFrame) -> pd.DataFrame:

    # set id column as index on both dfs
    df_a_scores['id.1'] = pd.to_numeric(df_a_scores['id.1'], errors='coerce')
    df_a_scores = df_a_scores.set_index('id.1')

    df_b_c_scores['id.1'] = pd.to_numeric(df_b_c_scores['id.1'], errors='coerce')
    df_b_c_scores = df_b_c_scores.set_index('id.1')

    # concat into one df
    scores_df = pd.concat([df_a_scores, df_b_c_scores], axis=1)

    # sort on index
    scores_df = scores_df.sort_index()

    # get 'Monitor and Peripherals Score'
    scores_df['monitor_peripherals_scores'] = scores_df.apply(lambda x: get_score_from_card(x['score_b_rosa'], x['score_c_rosa'], rosa_sc.card_map), axis=1)

    # get Rosa Final Score
    scores_df['final_rosa_score'] = scores_df.apply(lambda x: get_score_from_card(x['score_a_rosa'], x['monitor_peripherals_scores'], rosa_sc.card_final), axis=1)

    scores_df['final_rosa_score_normalized'] = ((scores_df['final_rosa_score'] - 1) / (10 - 1)).round(2)

    return scores_df